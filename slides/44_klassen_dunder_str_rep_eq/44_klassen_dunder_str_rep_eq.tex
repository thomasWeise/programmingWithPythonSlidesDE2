\pdfminorversion=7%
\documentclass[aspectratio=169,mathserif,notheorems]{beamer}%
%
\xdef\bookbaseDir{../../bookbase}%
\xdef\sharedDir{../../shared}%
\RequirePackage{\bookbaseDir/styles/slides}%
\RequirePackage{\sharedDir/styles/styles}%
\toggleToGerman%
%
\subtitle{43.~Klassen/Dunder:~\texttt{\_\_str\_\_}, \texttt{\_\_repr\_\_}, und \texttt{\_\_eq\_\_}}%
%
\begin{document}%
%
\startPresentation%
%
\section{Einleitung}%
%%
\begin{frame}[t]%
\frametitle{Einleitung}%
\begin{itemize}%
%
\item In \python, \emph{everything is an object}\cite{PSF:P3D:TPLR:OVAT,J2022PPEIAOSCD}, also \inQuotes{Alles ist ein Objekt}.%
%
\item<2-> Funktionen, Module, Klassen, Datentypen, Werte einfacher Datentypen, und so weiter -- alles sind Objekte.%
%
\item<3-> Viele dieser Objekte haben besondere Funktionen%
%
\item<4-> Zum Beispiel können wir numerische Objekte addieren, subtrahieren, multiplizieren und dividieren.%
%
\item<5-> Wir können die String-Repräsentation von allen Objekten bekommen und auf der Konsole ausgeben.%
%
\item<6-> Wir können über die Elemente von Objekten iterieren, die Sequenzen darstellen.%
%
\item<7-> Wir können Objekte ausführen, die Funktionen repräsentieren.%
%
\item<8-> Diese besonderen Funktionalitäten sind als so genannte \emph{dunder}-Methoden implementiert.%
%
\item<9-> \emph{Dunder} steht für \inQuotes{double underscore}, also \inQuotes{Doppelter Unterstrich}, also \pythonilIdx{\_\_}.%
%
\item<10-> Alle Namen solcher Methoden beginnen und enden nämlich mit \pythonilIdx{\_\_}.%
%
\end{itemize}%
\end{frame}%
%
%
\begin{frame}[t]%
\frametitle{Dunder Methoden}%
\begin{itemize}%
\item Alle Namen solcher Methoden beginnen und enden nämlich mit \pythonilIdx{\_\_}.%
%
\item<2-> Ein typisches Beispiel haben wir schon kennengelernt, nämlich den Initialisierer \dunder{init}, der die Attribute von Objekten erstellt.%
%
\item<3-> Wir haben auch gelernt das, wenn wir eine Subklasse von einer Klasse ableiten, sowohl neue Methoden definieren als auch existierende Methoden überschreiben können.%
%
\item<4-> Das können wir auch mit den Dunder-Methoden machen.%
%
\item<5-> Das heist, das wir im Grunde alle der vorher genannten Funktionalitäten erzeugen, verändern, und anpassen können!%
\end{itemize}%
\end{frame}%
%
\section{\texttt{\_\_str\_\_} und \texttt{\_\_repr\_\_}}
%
%
\begin{frame}[t]%
\frametitle{\texttt{\_\_str\_\_} und \texttt{\_\_repr\_\_}}%
\begin{itemize}%
%
\item Wir können zwei Arten von textuellen Repräsentationen eines Objekts~\pythonil{o} unterscheiden\only<-1>{.}\uncover<2->{%
%
\medskip\begin{enumerate}%
%
\item \pythonil{str(o)}\pythonIdx{str} sollte eine kurze Stringrepräsentation des Objekts~\pythonil{o} liefern\cite{PSF:P3D:TPLR:DM:S}.\uncover<3->{ %
Diese Repräsentation ist hauptsächlich für Endbenutzer.\uncover<4->{ %
\pythonil{str(o)} ruft die Dunder-Methode \dunder{str} von \pythonil{o} auf, wenn diese implementiert wurde.\uncover<5->{ %
Sonst ruft es \pythonil{o.__repr__()} auf.}}}\medskip%
%
\item<6-> \pythonil{repr(o)}\pythonIdx{repr} sollte idealerweise eine String-Repräsentation liefern, die alle Informationen beinhaltet, die notwendig sind, um das Objekt~\pythonil{o} erneut zu erzeugen\cite{PSF:P3D:TPLR:DM:R}.\uncover<7->{ %
Das Zielpublikum sind hier Programmier, die am Kode arbeiten, und die \DEzB\ genau Informationen in Log-Dateien schreiben oder nach Fehlern suchen müssen.\uncover<8->{ %
\pythonil{repr(o)} ruft die Dunder-Methode \dunder{repr} auf, wenn diese implementiert wurde.\uncover<9->{ %
Sonst wird er name des Datentyps und die ID des Objekts geliefert.%
}}}%
%
\end{enumerate}%
}%
\end{itemize}%
\end{frame}%
%
%
\begin{frame}[t]%
\frametitle{Beispiel: \texttt{str} und \texttt{repr}}%
%
\parbox{0.4\paperwidth}{\small{%
\begin{itemize}%
%
\only<-5>{%
\item In Programm \programUrl{dunder:str_vs_repr} vergleichen wir die beiden Funktionen.%
}%
%
\only<-5>{%
\item<2-> Wir erstellen zuerst eine Ganzzahl-Variable \pythonil{the_int} mit Wert \pythonil{123}.%
}%
%
\only<-6>{%
\item<3-> Sowohl \pythonil{str(the_int)} als auch \pythonil{repr(the_int)} liefern \pythonil{\"123\"}.%
}%
%
\only<-7>{%
\item<4-> Das erwarten wir so auch, denn das ist sowohl die kompakteste Variante, den Wert darzustellen, als auch alle Information, die man braucht, um ihn neu zu erzeugen.%
}%
%
\only<-9>{%
\item<5-> Wir erstellen eine Variable \pythonil{the_str} mit Wert \pythonil{\"123\"}.%
}%
%
\only<-10>{%
\item<6-> Wenn wir \pythonil{the_str} auf dem \glsFull{stdout} ausgeben, wenn wir also \pythonil{print(str(the_str))} machen, dann taucht der Text \textil{123} auf der Konsole auf.%
}%
%
\only<-11>{%
\item<7-> Drucken wir dagegen \pythonil{repr(the_str)} aus, dann erscheint \textil{\'123\'}.%
}%
%
\only<-12>{%
\item<8-> Beachten Sie die einzelnen Anführungszeichen an beiden Enden?%
}%
%
\only<-13>{%
\item<9-> Diese sind notwendig.%
}%
%
\only<-14>{%
\item<10-> Ohne sie wären \pythonil{repr(the_str)} und \pythonil{repr(the_int)} gleich.%
}%
%
\only<-15>{%
\item<11-> Wir könnten nicht unterscheiden, ob ein String oder eine Ganzzahl ausgegeben wurde.%
}%
%
\only<-16>{%
\item<12-> Das spielt natürlich nur eine Rolle, wenn wir uns für die innere Arbeitsweise unseres Programms interessieren.%
}%
%
\only<-17>{%
\item<13-> Und genau dafür existiert \pythonilIdx{repr}.%
}%
%
\only<-18>{%
\item<14-> Nun erstellen wir zwei Kollektionen.%
}%
%
\only<-19>{%
\item<15-> Zuerst erzeugen wir die Liste~\pythonil{l1}, die die drei Ganzzahlen~\pythonil{1}, \pythonil{2} und~\pythonil{3} beinhaltet.%
}%
%
\only<-19>{%
\item<16-> Dann erstellen wir die List~\pythonil{l2}, die drei Strings, nämllich~\pythonil{\"1\"}, \pythonil{\"2\"} und~\pythonil{\"3\"}.%
}%
%
\only<-20>{%
\item<17-> Dann wenden wir geben wir beide Listen aus wobei intern \pythonil{str(l1)} und \pythonil{str(l2)} werden.%
}%
%
\only<-21>{%
\item<18-> Das Ergebnis von \pythonil{print(f\"\{l1 = \}, but \{l2 = \}\")} ist \textil{l1 = [1, 2, 3],} \textil{but l2 = ['1', '2', '3']}.%
}%
%
\only<-22>{%
\item<19-> Beachten Sie wieder die einzelnen Anführungszeichen um die String-Elemente von \pythonil{l2}.%
}%
%
\only<-23>{%
\item<20-> Wenn die textuelle Repräsentation der Standard-Kollektionstypen von \python\ mit \pythonilIdx{str} oder \pythonilIdx{repr} erzeugt wird, dann weden die Elemente der Kollektionen immer \pythonilIdx{repr} zu Strings konvertiert, nie mit~\pythonilIdx{str}\cite{PEP3140}.%
}%
%
\only<-25>{%
\item<21-> Andernfalls könnten wir nicht zwischen \pythonil{l1} und \pythonil{l2} in der Ausgabe unterscheiden.%
}%
%
\only<-25>{%
\item<22-> Ein anderes gutes Beispiel für den Unterschied zwischen \pythonilIdx{str} und \pythonilIdx{repr} ist \python's Klasse \pythonilIdx{datetime}.%
}%
%
\only<-26>{%
\item<23-> Wir diskutieren diese Klasse hier nicht im Detail.%
}%
%
\only<-26>{%
\item<24-> Es reicht zu wissen, dass Instanzen dieser Klasse eine Kombination aus Datum und Uhrzeit darstellen.%
}%
%
\only<-27>{%
\item<25-> Im Programm importieren wir erst die Klasse \pythonilIdx{datetime} aus dem Modul mit dem selben Namen.%
}%
%
\only<-28>{%
\item<26-> Wir erstellen eine Variable \pythonil{right\_now}, die das Ergebnis der Funktion \pythonilIdx{datetime.now} zugewiesen bekommt, die ein Objekt zurückliefert, in dem das aktuelle Datum und die aktuelle Uhrzeit gespeichert sind.%
}%
%
\only<-29>{%
\item<27-> Wenn wir das Ergebnis der Funktion \pythonil{str} auf ein Objekt~\pythonil{o} in einem \glslink{fstring}{f-String} ausgeben wollen, dann benutzen wir die Format-Spezifikation~\pythonil{!s}\pythonIdx{"!s}, schreiben also~\pythonil{f\"\{o!s\}\"}.%
}%
%
\only<-31>{%
\item<28-> Wir sehen, dass die String-Repräsentation von einem \pythonilIdx{datetime}-Objekt ein einfacher, leicht lesbarer Datums- und Uhrzeit-String ist.%
}%
%
\only<-32>{%
\item<29-> Das Ergebnis der Funktion \pythonilIdx{repr} für ein Objekt~\pythonil{o} in einem \glslink{fstring}{f-String} wird mit der Format-Spezifikation~\pythonil{!r}\pythonIdx{"!r} abgefragt, also durch~\pythonil{f\"\{o!r\}\"}.%
}%
%
\only<-33>{%
\item<30-> Machen wir das mit einem \pythonilIdx{datetime}-Objekt, dann bekommen wir tatsächlich die Information, die wir brauchen, um das Objekt wieder zu erzeugen.%
}%
%
\item<31-> Wir könnten die Ausgabe von \pythonilIdx{repr} direkt in die \python-Konsole kopieren!%
%
\item<32-> Das würde ein \pythonilIdx{datetime}-Objekt mit genau den selben Daten wie \pythonil{right\_now} erzeugen.%
%
\item<33-> Das würde auch mit den String-Repräsentationen der beiden Listen \pythonil{l1} und \pythonil{l2} oben funktionieren.%
\end{itemize}%
}}%
%
\gitLoadAndExecPython{dunder:str_vs_repr}{}{dunder}{str_vs_repr.py}{}%
\listingPythonAndOutput{}{dunder:str_vs_repr}{}{0.45}{0.01}{0.54}{0.99}%
\end{frame}%
%
%
\section{Strings und Gleichheit}
%
\begin{frame}[t]%
\frametitle{Beispiel: \texttt{Point} und Gleichheit}%
%
\parbox{0.4\paperwidth}{\small{%
\begin{itemize}%
%
\only<-5>{%
\item Gehen wir noch ein paar Schritte zurück zu einem Beispiel, das wir selbst erstellt haben.%
}%
%
\only<-6>{%
\item<2-> Wir erinnern uns an die Klasse \pythonil{Point}, mit der wir Punkte in der zweidimensionalen Euklidischen Ebene dargestellt haben.%
}%
%
\only<-7>{%
\item<3-> Diese Klasse war ziemlich nützlich, als wir Klassen für verschiedene Formen implementiert haben.%
}%
%
\only<-8>{%
\item<4-> Damals haben wir schon die Dunder-Methode \dunder{init} kennengelernt.%
}%
%
\only<-9>{%
\item<5-> Spielen wir mit der Klasse etwas mehr.%
}%
%
\only<-10>{%
\item<6-> Im Programm \programUrl{dunder:point_user_2} erstellen wir drei Instanzen dieser Klasse.%
}%
%
\only<-11>{%
\item<7-> \pythonil{p1} steht für die Koordinaten~$(3,5)$, \pythonil{p2}~speichert~$(7, 8)$ und~\pythonil{p3} hat die selben Koordinaten wie \pythonil{p1}.%
}%
%
\only<-12>{%
\item<8-> In diesem Program geben wir erstmal die Ergebnisse von \pythonil{str} und \pythonil{repr} für \pythonil{p1} aus.%
}%
%
\only<-12>{%
\item<9-> Wir erkennen sofort, dass sie eher nutzlos sind.%
}%
%
\only<-13>{%
\item<10-> Da wir weder \dunder{str} noch \dunder{repr} implementiert haben, greift \pythonil{str} auf \dunder{repr} zurück, welches dann einfach den Typename und die Objekt-ID liefert.%
}%
%
\only<-15>{%
\item<11-> Für uns sind das keine nützlichen Informationen.%
}%
%
\only<-16>{%
\item<12-> Wenn wir gerade bei \inQuotes{nicht nützlich} sind, da ist noch ein anderer Aspekt unserer Klasse  \pythonil{Point}, der sich nicht nützlich verhält.%
}%
%
\only<-17>{%
\item<13-> In Einheit~\unitEqualityIdentiy\ hatten wir den Unterschied zwischen der Gleichheit und der Identität von Objekten diskutiert.%
}%
%
\only<-18>{%
\item<14-> Alle drei Variablen \pythonil{p1}, \pythonil{p2} und~\pythonil{p3} zeigen auf verschiedene Objekte.%
}%
%
\only<-19>{%
\item<15-> Während \pythonil{p1 is p1}\pythonIdx{is} offensichtlich \pythonil{True} ist, müssen \pythonil{p1 is p2} und \pythonil{p1 is p3} offensichtlich \pythonil{False} sein.%
}%
%
\only<-20>{%
\item<16-> Die drei Objekte sind alle verschiedene Instanzen von \pythonil{Point}, also erwarten wir das genau so.%
}%
%
\only<-21>{%
\item<17-> Es ist aber ärgerlich, dass \pythonil{p1 == p3}\pythonIdx{==} auch \pythonil{False} ergibt.%
}%
%
\only<-22>{%
\item<18-> \pythonil{p1 == p2} soll \pythonil{False} sein, weil diese beiden Punkte unterschiedlich sind.%
}%
%
\only<-23>{%
\item<19-> Die beiden Punkte \pythonil{p1} und \pythonil{p3} haben aber die selben Koordinaten.%
}%
%
\only<-24>{%
\item<20-> Sie sollten als gleich betrachtet werden.%
}%
%
\only<-24>{%
\item<21-> Andersherum ist \pythonil{p1 != p2}\pythonIdx{"!=} \pythonil{True}, so wie es seien soll, aber \pythonil{p1 != p3}\pythonIdx{"!=} sollte eigentlich \pythonil{False} seien, ist aber \pythonil{True}.%
}%
%
\only<-25>{%
\item<22-> Der Grund dafür ist das \python\ nicht wissen kann, wann und warum Instanzen unserer eigenen Klasse als gleich betrachtet werden sollen.%
}%
%
\only<-26>{%
\item<23-> Es nimmt einfach an, dass Gleichheit~$=$~Identity, also ein Objekt nur gleich zu sich selbst ist.%
}%
%
\only<-26>{%
\item<24-> Wir könnten das reparieren, in dem wir die Dunder-Methode \dunder{eq} selbst implementieren.%
}%
%
\only<-27>{%
\item<25-> Diese Methode bekommt ein beliebiges Objekt \pythonil{other} als Parameter und soll \pythonil{True} bei Gleichheit zurückliefern und \pythonil{False} sonst.%
}%
%
\only<-28>{%
\item<26-> Genau wie \pythonil{str(o)} \pythonil{o.__str__()} aufruft, so ruft der \pythonil{a == b}-Operator \pythonil{a.__eq__(b)} auf, wenn \pythonil{a} \dunder{eq} implementiert.%
}%
%
\only<-29>{%
\item<27-> Wenn Sie \dunder{eq} implementieren, dann wird \python\ annehmen das \pythonil{(a != b) ==} \pythonil{not (a == b)}\pythonIdx{"!=}\pythonIdx{==}, also annehmen, dass zwei Objekte ungleich sind, wenn sie nicht gleich sind\cite{PEP207}.%
}%
%
\only<-32>{%
\item<28-> Das ist muss nicht immer der Fall, obwohl ich kein Beispiel kenne, wo es nicht simmt\cite{programmingWithPython} {\dots} vielleicht war es früher mal so, dass das bei Fließkommazahlen auftreten konnte\cite{PEP754}, im Moment sehe ich das aber nicht.%
}%
%
\only<-33>{%
\item<29-> \python\ erlaubt uns auch, die Dunder-Methode \dunder{ne} zu implementieren, die von \pythonil{a != b} als \pythonil{a.__ne__(a)} aufgerufen wird.\cite{PEP207}%
}%
%
\only<-34>{%
\item<30-> Zum Schluss vergleichen wir noch, ob \pythonil{p1} das selbe wie die Ganzzahl \pythonil{5} ist.%
}%
%
\only<-35>{%
\item<31-> Das sollte offensichtlich \pythonil{False} ergeben.%
}%
%
\item<32-> Und das tut es auch.%
%
\item<33-> Weil die beiden Objekte \pythonil{p1} und \pythonil{5} nicht identisch sind.%
%
\item<34-> Wie gesagt prüft der Standard-Gleichheits-Operator nur auf Identität.%
%
\item<35-> Falls wir \dunder{eq} selbst implementieren, dann muss die Methode \pythonil{False} zurückliefern, wenn sie \pythonil{5} als Argument bekommt~(anstatt abzustürzen oder eine Ausnahme auszulösen\dots).%
\end{itemize}%
}}%
%
\gitLoadPython{classes:point}{}{classes/point.py}{}%
\listingPython{-4}{classes:point}{0.48}{0.01}{0.54}{0.99}%
%
\gitLoadAndExecPython{dunder:point_user_2}{}{dunder}{point_user_2.py}{}%
\listingPythonAndOutput{5-}{dunder:point_user_2}{}{0.45}{0.07}{0.54}{0.97}%
\end{frame}%
%
\begin{frame}[t]%
\frametitle{Beispiel: \texttt{Point} mit Dunder Methoden}%
%
\parbox{0.4\paperwidth}{\small{%
\begin{itemize}%
%
\only<-4>{%
\item Um die vorhin genannten Probleme alle zu lösen, implementieren wir die drei Dunder-Methoden \dunder{str}, \dunder{repr} und \dunder{eq} in unserer \pythonil{Point}-Klasse in Datei \programUrl{dunder:point_with_dunder}.%
}%
%
\only<-5>{%
\item<2-> Die kurze String-Repräsentation, die \dunder{str} liefert, beinhaltet einfach die Punkt-Koordinaten, mit Komma getrennt, in Klammern.%
}%
%
\only<-7>{%
\item<3-> Das liefert alle Informationen auf einen Blick, aber es könnte mit der String-Repräsentation eines Tupels verwechselt werden.%
}%
%
\only<-8>{%
\item<4-> Deshalb wird \dunder{repr} einen String der Form \pythonil{\"Point(x, y)\"} liefern.%
}%
%
\only<-9>{%
\item<5-> Die Dunder-Methode \dunder{eq} prüft erst, ob das andere Objekt eine Instanz von \pythonil{Point} ist.%
}%
%
\only<-10>{%
\item<6-> Wenn ja, dann liefert sie \pythonil{True} genau dann wenn die \pythonil{x}-\ und \pythonil{y}-Koordinate des Punkts \pythonil{other} die gleichen sind wie die des Punkts \pythonil{self}.%
}%
%
\only<-11>{%
\item<7-> Andernfalls liefert sie die Konstante \pythonilIdx{NotImplemented} zurück.%
}%
%
\only<-12>{%
\item<9-> In dem wir \pythonilIdx{NotImplemented} bei \pythonil{other}-Objekten, die keine Instanzen von  \pythonil{Point} sind, zurückliefern, dann verweisen wir einfach auf das Standardverhalten des Operators~\pythonil{==}.%
}%
%
\only<-13>{%
\item<10-> Wenn \pythonil{other} keine Instanz von \pythonil{Point}, dann gibt es keine Möglichkeit, auf Gleichheit zu vergleichen.%
}%
%
\only<-14>{%
\item<11-> Wir könnten in diesem Fall einfach \pythonil{False} zurückliefern, was auch OK wäre.%
}%
%
\item<12-> \pythonilIdx{NotImplemented} zu liefern gibt uns das gleiche Ergebnis wenn wir mit Objekten eines anderen Typs vergleichen wie \DEzB~\pythonil{5}.%
%
\item<13-> Es ermöglicht aber anderen Programmieren, eine neue Klasse zu schreiben, die einen Gleichheitsvergleich mit unseren \pythonil{Point}-Instanzen implementiert.%
%
\item<14-> Wenn wir \dunder{eq} implementieren, dann ist der richtige \glslink{typeHint}{Type Hint} für den Rückgabewert \pythonil{bool | NotImplementedType}\pythonIdx{NotImplementedType}.%
\end{itemize}%
}}%
%
\locate{8}{%
\parbox{0.505\paperwidth}{\noindent%
\setlength{\paperwidth}{\linewidth}%
{\huge{%
\cquotation{PSF:P3D:TPSL:BIC}{\huge{%
A special value which should be returned by the binary special methods [\dots] to indicate that the operation is not implemented with respect to the other type\dots\medskip\\\strut\hspace{1cm}\strut%
\emph{Note:}~When a binary~(or in-place) method returns \pythonilIdx{NotImplemented} the interpreter will try the reflected operation on the other type~(or some other fallback, depending on the operator). %
If all attempts return \pythonilIdx{NotImplemented}, the interpreter will raise an appropriate exception. %
Incorrectly returning \pythonilIdx{NotImplemented} will result in a misleading error message or the \pythonilIdx{NotImplemented} value being returned to \python\ code.%
}}%
}}%
}}{0.475}{0.2}%
%
\gitLoadPython{dunder:point_with_dunder}{}{dunder/point_with_dunder.py}{}%
\listingPython{1}{dunder:point_with_dunder}{0.55}{0.01}{0.54}{0.99}%
\listingPython{2-7,9-}{dunder:point_with_dunder}{0.48}{-0.15}{0.54}{1.15}%
\end{frame}%
%
%
%
\begin{frame}[t]%
\frametitle{Beispiel: \texttt{Point} mit Dunder Methoden benutzen}%
%
\parbox{0.4\paperwidth}{\small{%
\begin{itemize}%
\only<-4>{%
\item Wir benutzen nun unsere neue Klasse \pythonil{Point} genauso wie wir die alte in Program \programUrl{dunder:point_user_2} verwendet haben.%
}%
%
\only<-5>{%
\item<2-> Das tun wir in dem neuen Programm \programUrl{dunder:point_with_dunder_user}.%
}%
%
\only<-6>{%
\item<3-> Die Ausgabe dieses Programms passt viel besser zu dem, was wir uns vorstellen.%
}%
%
\item<4-> Die Funktion \pythonil{str} liefert uns nun kurzen aber informativen Output für Instanzen der Klasse \pythonil{Point}.%
%
\item<5-> Der \pythonil{repr}-Operator gibt uns Text, den wir im Prinzip in den \python-Interpreter kopieren könnten und mit dem wir so das gleiche Objekt nochmal erstellen könnten.%
%
\item<6-> Die Gleicheits- und Ungleichheits-Operatoren zeigen ebenfalls viel vernünftigeres Verhalten und sehen, wenn zwei Punkte die selben Koordinaten haben.%
%
\item<7-> Sie funktionieren auch richtig wenn das andere Objekt kein Punkt ist.%
\end{itemize}%
}}%
%
%
\listingPythonAndOutput{-1}{dunder:point_user_2}{}{0.45}{0.07}{0.54}{0.97}%
\gitLoadAndExecPython{dunder:point_with_dunder_user}{}{dunder}{point_with_dunder_user.py}{}%
\listingPythonAndOutput{2-}{dunder:point_with_dunder_user}{}{0.45}{0.07}{0.54}{0.97}%
\end{frame}%
%
\section{Zusammenfassung}%
%
\begin{frame}[t]%
\frametitle{Zusammenfassung}%
%
\begin{itemize}%
\item Wir haben nun unsere Reise in das Reich der so genannten \emph{Dunder}-Methoden begonnen.%
%
\item<2-> Diese Methoden kontrollieren viel von dem Verhalten der Operatoren und Konstrukte der Sprache \python.%
%
\item<3-> Mit \dunder{str}, \dunder{repr}, \dunder{eq} und \dunder{ne} haben wir bereits vier Methoden berührt, die wir bereits sehr oft verwendet haben -- wenn auch indirekt.%
%
\item<4-> Welche anderen Abenteuer erwarten uns so tief im Getriebe der \python-Machine?%
\end{itemize}%
\end{frame}%
%
\endPresentation%
\end{document}%%
\endinput%
%
