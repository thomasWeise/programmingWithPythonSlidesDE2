\pdfminorversion=7%
\documentclass[aspectratio=169,mathserif,notheorems]{beamer}%
%
\xdef\bookbaseDir{../../bookbase}%
\xdef\sharedDir{../../shared}%
\RequirePackage{\bookbaseDir/styles/slides}%
\RequirePackage{\sharedDir/styles/styles}%
\toggleToGerman%
%
\subtitle{40.~Operationen für Iteratoren}%
%
\begin{document}%
%
\startPresentation%
%
\section{Einleitung}%
%%
\begin{frame}%
\frametitle{Einleitung}%
\begin{itemize}%
\item Sequenzen spielen eine sehr wichtige Rolle in der \python-Programmierung.%
%
\item<2-> Der Fakt das Generator-Funktionen und das Schlüsselwort \pythonilIdx{yield} zur Sprache hinzugefügt wurden, nur um eine natürliche Möglichkeit zum konstruieren komplizierte Sequenzen bereitzustellen, spricht für sich selbst\cite{PEP255}.%
%
\item<3-> Natürlich gibt es auch viele weitere Werkzeuge, um Sequenzen zu bearbeiten und zu transformieren.%
%
\item<4-> Einige davon sind direkt in die Sprache eingebaute Funktionen, andere kommen in dem Modul \pythonilIdx{itertools}\cite{PSF:P3D:TPSL:IFCIFEL}.%
%
\item<5-> Hier wollen wir ein paar von ihnen diskutieren.%
\end{itemize}
\end{frame}%
%
\section{\texttt{filter} und \texttt{takewhile}}%
%
%
\begin{frame}[t]%
\frametitle{\texttt{filter} und \texttt{takewhile}}%
%
\parbox{0.4\paperwidth}{\small{%
\begin{itemize}%
\only<-5>{%
\item Die ersten beiden Funktionen, die wir uns anschauen, sind die built-in Funktion \pythonilIdx{filter} und die Funktion \pythonilIdx{takewhile}\pythonIdx{itertools!takewhile} aus dem Modul \pythonilIdx{itertools}.%
}%
%
\only<-6>{%
\item<2-> In der letzten Einheit haben wir in Datei \programUrl{iteration:prime_generator} eine Generator-Funktion implementiert, die eine endlose Sequenz von Primzahlen zurückliefert.
}%
%
\only<-7>{%
\item<3-> Gibt es eine bequeme Möglichkeit, eine Liste aller Primzahlen die kleiner als 50 sind zurückzuliefern?%
}%
%
\only<-8>{%
\item<4-> Die Antwort ist \emph{Ja}.%
}%
%
\only<-9>{%
\item<5-> \pythonilIdx{takewhile} ist eine Function mit zwei Parametern\cite{PSF:P3D:TPSL:IFCIFEL}.%
}%
%
\only<-9>{%
\item<6-> Der zweite Parameter ist ein \pythonilIdx{Iterable}.%
}%
%
\only<-10>{%
\item<7-> Sagen wir, dass dieses \pythonilIdx{Iterable} eine Sequenz von Elementen von einem Type~\pythonil{T} bereitstellt.%
}%
%
\only<-10>{%
\item<8-> Der erste Parameter ist dann ein Prädikat, also eine Funktion die ein Element vom Typ~\pythonil{T} akzeptiert und einen \pythonil{bool}-Wert zurückgibt.%
}%
%
\only<-12>{%
\item<9-> Dann konstruiert \pythonilIdx{takewhile} einen \emph{neuen} \pythonilIdx{Iterator}, der die Elemente des ursprünglichen \pythonil{Iterable} zurückliefert \emph{so lange das Prädikat wahr für diese ist}.%
}%
%
\only<-13>{%
\item<10-> Sobald es bei einem Element aus dem originalen \pythonil{Iterable} ankommt, für das das Prädikat \pythonil{False} ergibt, wird die Iteration abgebrochen.%
}%
%
\only<-15>{%
\item<11-> In Einheit~\unitCallablesAndLambdas\ haben wir gelernt, dass wir auch Funktionen oder \pythonilsIdx{lambda} als Argumente an andere Funktionen übergeben können.%
}%
%
\only<-16>{%
\item<12-> Das ist ein praktisches Beispiel, wo \pythonilsIdx{lambda} besonders nützlich sind.%
}%
%
\only<-17>{%
\item<13-> Die Antwort auf \inQuotes{Wie bekomme ich alle Primzahlen weniger als 50 aus unsere Primzahlsequenz?} ist, einfach \pythonil{takewhile(lambda z:} \pythonil{z < 50, primes())} aufzurufen.%
}%
%
\only<-18>{%
\item<14-> Diese Sequenz ist nicht mehr endlos land und kann bequem in eine \pythonil{list} umgewandelt werden.%
}%
%
\only<-19>{%
\item<15-> Die built-in Funktion \pythonilIdx{filter} funktioniert sehr ähnlich\cite{PSF:P3D:TPSL:BIF}.%
}%
%
\only<-20>{%
\item<16-> Auch sie akzeptiert ein Prädikat und einen \pythonilIdx{Iterable} als Parameter.%
}%
%
\only<-20>{%
\item<17-> Anders als \pythonil{takewhile} bricht der von \pythonil{filter} erzeugte neue \pythonilIdx{Iterator}  nicht ab, wenn das Prädikat \pythonil{False} liefert.%
}%
%
\only<-21>{%
\item<18-> Stattdessen liefert er nur die Elemente zurück, für welche das Prädikat \pythonil{True} liefert.%
}%
%
\only<-22>{%
\item<19-> Wir benutzen das, um Primzahlen~$x$ zu generieren, für die es eine Ganzzahl~$y$ gibt so das~$x=y^2+1$.%
}%
%
\only<-24>{%
\item<20-> Wir implementieren dieses Prädikat ebenfalls als \pythonilIdx{lambda}.%
}%
%
\item<21-> Weil der von \pythonil{primes()} gelieferte \pythonilIdx{Iterator} eine unendliche Sequenz liefert, benutzen wir wieder \pythonilIdx{takewhile} und limitieren die Ausgabe auf Primzahlen die kleiner als 1000 sind.%
%
\item<22-> Wir übergeben das Ergebnis unseres Konstrukt an die Funktion \pythonil{tuple}, die eine unveränderliche und indizierbare Sequenz erstellt.%
%
\item<23-> Wir finden zehn Primzahlen, die unseren Bedingungen entsprechen.%
%
\item<24-> Die kleinste ist $1^2+1=2$ und die größte ist $26^2+1=677$.%
\end{itemize}%
}}%
%
\gitLoadAndExecPython{iteration:filter_takewhile}{}{iteration}{filter_takewhile.py}{}%
\listingPythonAndOutput{}{iteration:filter_takewhile}{}{0.45}{0.16}{0.54}{0.89}
%
\end{frame}%
%
\section{\texttt{map}}%
%
%
\begin{frame}[t]%
\frametitle{\texttt{map}}%
%
\parbox{0.4\paperwidth}{\small{%
\begin{itemize}%
\only<-4>{%
\item Eine weitere wichtige Funktion für Sequenzen ist die built-in Funktion~\pythonilIdx{map}\cite{PSF:P3D:TPSL:BIF}.%
}%
%
\only<-5>{%
\item<2-> Wir probieren sie in \programUrl{iteration:map} aus.%
}%
%
\only<-5>{%
\item<3-> In Einheit~\unitGeneratorExpressions\ haben wir einen Generator-Ausdruck verwendet, um Daten aus einem String im \glsFull{CSV}-Format zu ziehen.%
}%
%
\only<-7>{%
\item<4-> Anstatt \pythonil{int(s) for s} \pythonil{in csv_text.split(\",\")} können wir einfach \pythonil{map(int, csv_text.split(\",\")} schreiben.%
}%
%
\only<-9>{%
\item<5-> Das erste Argument von \pythonilIdx{map} ist eine Funktion, die auf die Elemente des \pythonilIdx{Iterable} angewandt wird, der als zweites Argument bereitgestellt wird.%
}%
%
\only<-10>{%
\item<6-> Das Ergebnis von \pythonilIdx{map} ist dann ein neuer \pythonilIdx{Iterator} mit den Rückgabewerten der Funktion.%
}%
%
\only<-11>{%
\item<7-> In \programUrl{iteration:map}, zerteilen wir den \pythonil{csv_text} basierend auf dem Separator \pythonil{\",\"}.%
}%
%
\only<-12>{%
\item<8-> Dann übersetzen wir die Elemente der resultierenden Liste zu \pythonilsIdx{int} via \pythonil{map}.%
}%
%
\only<-13>{%
\item<9-> Zuletzt filtern wir die Sequenz und behalten nur die Werte, die größer als 20 sind.%
}%
%
\only<-13>{%
\item<10-> Über die gefilterte und gemappte Sequenz können wir dann bequem mit einer \pythonilIdx{for}-Schleife iterieren.%
}%
%
\only<-14>{%
\item<11-> Wir wäre es nun, wenn wir alle Quadratzahlen der Werte aus den \pgls{CSV}-Daten laden wollen, aber jede Zahl nur einmal?%
}%
%
\only<-16>{%
\item<12-> Wir würden also alle Duplikate löschen.%
}%
%
\only<-17>{%
\item<13-> Wir benutzen dafür wieder \pythonilIdx{split}\pythonIdx{str!split} um den Text in durch \pythonil{\",\"} getrennte Stücke zu zerteilen.%
}%
%
\only<-18>{%
\item<14-> Wir übersetzen die Stücke zu \pythonil{int} und berechnen ihre Quadrate mit der \pythonilIdx{map}-Funktion, stellen diesmal aber ein \pythonilIdx{lambda} zur Verfügung, das die Transformation in einem Schritt durchführt.%
}%
%
\only<-19>{%
\item<15-> Nun wollen wir eine duplikatfrei Kollektion dieser Daten bekommen.%
}%
%
\only<-20>{%
\item<16-> Das geht, in dem wir den \pythonilIdx{Iterator}, den \pythonil{map} liefert, einfach an den \pythonilIdx{set}-Konstruktor übergeben.%
}%
%
\only<-21>{%
\item<17-> Eine Menge ist per definition duplikatfrei.%
}%
%
\only<-22>{%
\item<18-> In der Ausgabe sehen wir, dass die \textil{9} tatsächlich nur einmal auftaucht, genau wie die \textil{144}.%
}%
%
\only<-23>{%
\item<19-> Die Function \pythonilIdx{map} arbeitet auch gut mit Aggregatfunktionen wir \pythonilIdx{sum}, \pythonilIdx{min}, oder \pythonilIdx{max} zusammen.%
}%
%
\only<-24>{%
\item<20-> Im letzten Beispiel haben wir eine Liste \pythonil{words} von Worten und wollen die Länge des längsten Wortes bestimmen.%
}%
%
\only<-24>{%
\item<21-> Dazu mappen wir zuerst jedes Wort zu seiner Länge via \pythonil{map(len, words)}.%
}%
%
\only<-25>{%
\item<22-> Wir bekommen einen \pythonilIdx{Iterator} der Wortlängen, den wir direkt an \pythonilIdx{max} übergeben können.%
}%
%
\item<23-> \pythonil{max} iteriert dann über diese Sequenz und liefert deren größten Wert.%
%
\item<24-> Beachten Sie, dass \pythonilIdx{map} keine Datenstruktur mit all den transformierten Werten im Speicher erzeugt.%
%
\item<25-> Stattdessen wird jedes Element dann erzeugt, wenn es gebraucht wird~(und durch die Garbage Collection freigegeben, wenn es nicht mehr gebraucht wird).%
%
\item<26-> \pythonilIdx{map} ist daher eine elegante und effiziente Methode, um Daten zu transformieren.%
\end{itemize}%
}}%
%
\gitLoadAndExecPython{iteration:map}{}{iteration}{map.py}{}%
\listingPythonAndOutput{}{iteration:map}{}{0.45}{0.16}{0.54}{0.89}%
%
\end{frame}%
%
%
\section{\texttt{zip}}%
%
%
\begin{frame}[t]%
\frametitle{\texttt{zip}}%
%
\parbox{0.4\paperwidth}{\small{%
\begin{itemize}%
%
\only<-4>{%
\item Als letztes Beispiel für Sequenz-Verarbeitung spielen wir ein wenig mit der Funktion \pythonilIdx{zip}\cite{PSF:P3D:TPSL:BIF}.%
}%
%
\only<-5>{%
\item<2-> Diese Funktion akzeptiert mehrere \pythonilsIdx{Iterable} als Argumente und liefert einen \pythonilIdx{Iterator} als Ergebnis, der alle Iterables synchron durchiteriert und Tupel mit jeweils einem Wert von allen zurückliefert.%
}%
%
\only<-6>{%
\item<3-> Zum Bespiel liefert \pythonil{zip([1, 2, 3],} \pythonil{[\"a\", \"b\", \"c\"])} einen \pythonilIdx{Iterator} der die Sequenz \pythonil{(1, \"a\")}, \pythonil{(2, \"b\")}, und \pythonil{(3, \"c\")} produziert.%
}%
%
\only<-7>{%
\item<4-> Manchmal haben die \pythonilsIdx{Iterable} verschiedene Längen.%
}%
%
\only<-8>{%
\item<5-> Um sicherzustellen, dass so ein Fehler einen \pythonilIdx{ValueError} auslöst, müssen wir \alert{immer} den Parameter~\pythonil{strict=True} angeben\cite{PEP618}.%
}%
%
\only<-9>{%
\item<6-> In \programUrl{iteration:zip} benutzen wir \pythonilIdx{zip} um eine Funktion \pythonil{distance} zu implementieren, die den Euklidischen Abstand von zwei $n$\nobreakdashes-dimensionalen Vektoren oder Punkten \pythonil{p1} und \pythonil{p2} berechnet.%
}%
%
\only<-11>{%
\item<7-> Die beiden Punkte werden als \pythonilsIdx{Iterable} von entweder \pythonil{float} oder \pythonil{int} als Parameter bereitgestellt.%
}%
%
\only<-11>{%
\item<8-> Wir könnten sie also \DEzB\ als \pythonils{lists} angeben.%
}%
%
\only<-11>{%
\item<9-> Der Euklidische Abstand ist definiert als\uncover<9->{
%
\begin{equation}%
\nonumber\hspace{-2em}\pythonil{distance(p1, p2)} = \sqrt{\sum_{i=1}^n (\pythonil{p1}_i - \pythonil{p2}_i)^2}\nonumber%
\end{equation}}}%
%
%
\only<-13>{%
\item<10-> Wir müssen also über die Elemente beider Vektoren synchron iterieren.%
}%
%
\only<-14>{%
\item<11-> Das ist genau das, was \pythonilIdx{zip} macht.%
}%
%
\only<-14>{%
\item<12-> Wenn beide Punkte \DEzB\ als \pythonils{list} angegeben werden, dann wird \pythonil{zip(p1, p2, strict=True)} uns, Schritt für Schritt, die Tupel \pythonil{(p1[0], p2[0])}, \pythonil{(p1[1], p2[1])}, {\dots}, angeben, bis es an Ende der Listen kommt.%
}%
%
\only<-16>{%
\item<13-> Wir können nun den Generator-Ausdruck  \pythonil{(a - b) ** 2} \pythonil{for a, b in} \pythonil{zip(p1, p2, strict=True)} schreiben.%
}%
%
\only<-17>{%
\item<14-> Er benutzt das Auspacken der Tupel um die beiden Elemente \pythonil{a} und \pythonil{b} aus den Tupeln zu holen, die \pythonilIdx{zip} erstellt.%
}%
%
\only<-18>{%
\item<15-> Er berechnet dann das Quadrat der Differenz dieser zwei Elemente.%
}%
%
\only<-19>{%
\item<16-> In dem wir diesen Generator-Ausdruck als Parameter an die Funktion \pythonilIdx{sum} übergeben, bekommen wir die Summe deiser Quadrate.%
}%
%
\only<-20>{%
\item<17-> Schlussendlich benutzen wir die \pythonilIdx{sqrt}-Funktion aus dem Modul \pythonilIdx{math} um die Berechnung des Euklidischen Abstands zu komplettieren.%
}%
%
\only<-21>{%
\item<18-> Anstatt diese neue Funktion mit ein paar Beispielen manuell zu testen, machen wir das lieber mit einem \glslink{doctest}{Doctest}.%
}%
%
\only<-22>{%
\item<19-> Der \glslink{doctest}{Doctest} zeigt dass der Abstand von zwei identischen Vektoren mit den selben Werten \pythonil{[1, 1]} unbedingt \pythonil{0.0} sein muss.%
}%
%
\only<-23>{%
\item<20-> \pythonil{distance((0.0, 1.0, 2.0, 3.0),} \pythonil{(1.0, 2.0, 3.0, 4.0))}, welcher im Grunde $\sqrt{1 + 1 + 1 + 1}$ ist, soll \pythonil{2.0} sein.%
}%
%
\item<21-> Der Abstand zweier eindimensionaler Vektoren \pythonil{[100]} und \pythonil{[10]} soll \pythonil{90.0} betragen.%
%
\item<22-> Geben wir dagegen zwei Vektoren verschiedener Länge an, dann soll das zu der Ausnahme \pythonilIdx{ValueError} führen.%
%
\item<23-> Wir sehen am Output von \pytest, dass unsere Funktion diese Tests besteht.
%
\end{itemize}%
}}%
%
\gitLoadPython{iteration:zip}{}{iteration/zip.py}{}%
\gitExec{exec:iteration:zip:doctest}{\programmingWithPythonCodeRepo}{.}{_scripts_/pytest_doctest.sh iteration zip.py}%
%
\listingPython{-22}{iteration:zip}{0.48}{0.1}{0.54}{0.99}%
\listingOutput{23-}{iteration:zip:doctest}{style=tool_style}{0.45}{0.3}{0.54}{0.92}%
%
\end{frame}%
%
\section{Zusammenfassung}%
%
\begin{frame}%
\frametitle{Zusammenfassung: Operationen auf Iteratoren}%
%
\begin{itemize}%
\item Damit sind wir am Ende unseres kurzen Ausflugs zu den Operationen für \pythonilsIdx{Iterator}.%
%
\item<2-> Wir können hier wirklich nur ganz wenige Funktionen angucken, und diese auch nur oberflächlich.%
%
\item<3-> Das Modul \pythonilIdx{itertools}\cite{PSF:P3D:TPSL:IFCIFEL}, welches zu \python\ gehört, bietet noch viele weitere nützliche Funktionen.%
%
\item<4-> Ein Verständnis der Funktionen \pythonilIdx{map}, \pythonilIdx{filter}, und \pythonilIdx{zip} wird Ihnen aber sicherlich nützlich seien, wenn sie weitere Funktionen selbst erforschen.%
\end{itemize}%
\end{frame}%%
%
\begin{frame}%
\frametitle{Zusammenfassung: Sequenzen}%
%
\begin{itemize}%
\only<-8>{%
\item Arbeiten mit Sequenzen ist ein sehr wichtiger Aspekt vom \python-Programming.%
}%
%
\only<-8>{%
\item<2-> Die Programmiersprache stellt eine simplifizierte Syntax zum Arbeiten mit Schleifen in Form von Listen-, Mengen-, und Dictionary Comprehension zur Verfügung.%
}%
%
\only<-9>{%
\item<3-> Anders als Comprehension erlauben uns Generator-Ausdrücke, Sequenzen von Daten zu definieren, deren Elemente eins nach dem Anderen verarbeitet werden, ohne diese vorher erst alle im Speicher zu manifestieren.%
}%
%
\only<-10>{%
\item<4-> Stattdessen werden die Elemente erst erzeugt, wenn sie gebraucht werden.%
}%
%
\only<-11>{%
\item<5-> Wenn das Erstellen der Elemente komplexer ist, als wir mit Generator-Ausdrücken, nunja, ausdrücken können, dann können wir Generator-Funktionen verwenden.%
}%
%
\only<-11>{%
\item<6-> Mit deren \pythonilIdx{yield}-Statement erlauben ist uns Funktionen zu definieren, die Berechnungen durchführen und Ergebnisse als Ausgabe liefern, die dann vom aufrufenden Kode verarbeitet werden.%
}%
%
\item<7-> Anders als normale Funktionen wird ihre Ausführung danach fortgesetzt, bis sie weitere Ergebnisse mit \pythonilIdx{yield} zurückliefern oder das Ende der Sequenz erreicht ist.%
%
\item<8-> Sequenzen von Daten können mit vielen \python-Funktionen verarbeitet, transformiert, oder aggregiert werden.
%
\item<9-> Solche Funktionen können auf Kontainer, Comprehensions, oder Generatoren angewendet werden.
%
\item<10-> Das ist möglich, weil die gesamte \glsFull{API} zur Verarbeitung von Sequenzen letztendlich auf zwei Grundlegenden Komponenten baisert: \pythonilIdx{Iterator} und \pythonilIdx{Iterable}.%
%
\item<11-> An \pythonilIdx{Iterable} ist ein Interface das von allen Objekten bereitgestellt wird, deren Elemente eins nach dem Anderen ausgelesen werden können.%
%
\item<12-> Ein \pythonilIdx{Iterator} ist genau eine solche iterative Aufzählung, eine solcher sequentieller Zugriff auf die Elemente.%
\end{itemize}%
\end{frame}%
%
\endPresentation%
\end{document}%%
\endinput%
%
